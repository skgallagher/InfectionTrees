## binary covariate log like
## SKG
## Aug 17, 2020


#' Estimate the branching process log likelihood for a set of summarized trees
#'  with a single binary covariate
#'
#'  @param inf_params vector of length 2, the beta0 and beta1 coefficients
#'  @param mc_samples_summary a data frame of sampled transmission trees
#'  with the following columns (the last one is only needed for the multiple
#'  outsider model)
#'  \describe{
#'  \item{freq}{frequency of cluster with the following characteristics}
#'  \item{cluster_size}{size of the cluster}
#'  \item{x_pos}{number of x positives in the cluster}
#'  \item{x_neg}{number of x negatives in the cluster}
#'  \item{x_pos_trans}{number of transmissions from a positive individual in the tree}
#'  \item{x_neg_trans}{number of transmissions from a negative individual in the tree}
#'  \item{root_node_sign}{whether root node is pos or neg}
#'  }
#'  @param return_neg logical indicating whether to return the negative loglike.  Default is FALSE
#'  @param multiple_outsider_transmission logical indicating whether to use the outsider model likelihood or not
#'  @return the estimated log average likelihood over the observed clusters
bp_loglike_binary_cov <- function(inf_params,
                                  mc_samples_summary,
                                  return_neg = FALSE,
                                  multiple_outsider_transmissions = FALSE){

  total_p_pos <- sum(mc_samples_summary$freq *
                       mc_samples_summary$x_pos)
  total_p_neg <- sum(mc_samples_summary$freq *
                       mc_samples_summary$x_neg)
  emp_p_pos <- total_p_pos / (total_p_neg + total_p_pos)

  p_pos <- 1 / (1 + exp(-inf_params[1]))
  p_neg <- 1 / (1 + exp(-sum(inf_params)))

  if(!("data.table" %in% class(mc_samples_summary))){
    print("Converting 'sampled_data' to data.table format")
    mc_samples_summary <- data.table::as.data.table(mc_samples_summary)
  }
  if(multiple_outsider_transmissions){
    my_prob_inf <- (1-p_pos)^mc_samples_summary$x_pos *
      (1-p_neg)^mc_samples_summary$x_neg *
      p_pos^mc_samples_summary$x_pos_trans *
      p_neg^mc_samples_summary$x_neg_trans
  } else{ ## must condition on sign of the imputed outsider
    root_p <- ifelse(mc_samples_summary$root_node == 1, p_pos, p_neg)
    my_prob_inf <- (1-p_pos)^(mc_samples_summary$x_pos + 1) *
      (1-p_neg)^mc_samples_summary$x_neg *
      p_pos^mc_samples_summary$x_pos_trans *
      p_neg^mc_samples_summary$x_neg_trans / root_p

  }

  x_pos <- x_neg <-  NULL
  mc_samples_summary <- mc_samples_summary[, prob_inf := my_prob_inf]

  browser()

  like_df <- mc_samples_summary[,
                                .(avg_like = sum(freq * prob_inf)/ sum(freq)),
                                by = .(x_pos, x_neg)]

  loglike <- sum(log(like_df$avg_like))
  if(return_neg){
    loglike <- -loglike
  }

  if(is.na(loglike) | is.nan(loglike) |
     is.infinite(loglike)) {
    stop("loglike is NA/NAN/infinite")
  }

  return(loglike)


}
